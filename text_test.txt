tokens: usingSystem . Collections . Generic ; usingSystem . IO ; usingSystem . Linq ; usingSystem ; usingSystem . Text . RegularExpressions ; usingSystem . Collections . Concurrent ; usingSystem . Threading . Tasks ; usingSystem . Globalization ; usingSystem . Net ; usingJiebaNet . Segmenter ; usingNMeCab ; usingSystem . Text ; namespaceNGramm {} publicclassNgrammProcessor {} privateconstintProgressDivider = 1_000 ; boolignore_spaces = false ; boolignore_nlines = false ; boolignore_ends = false ; publicstaticstringsigns = "" ; publicstringss = "" ; publicstaticHashSet < char > endsigns = newHashSet < char > () "" . ToCharArray () ; publicstaticstringendsignss = "" ; publicstringrawTextorg = "" ; publicEncodingfileEncoding ; publicintCountDesiredVariables = 0 ; publicstringunsignedTextorg = "" ; publicstringendsignedTextorg = "" ; publicstringraw = "" ; publicstaticboolprocess_spaces = true ; publicstaticboolconsequtive_spaces = true ; publicstaticboolshow_NBS = true ; publicstaticboolignore_case = true ; publicstaticboolignore_punctuation = true ; privatestaticHashSet < char > spaces_list = newHashSet < char > {} '' , '' , '' , '' , '' , '' , '' , '' , '' , '' , '' , '' , '' , '' , '' , '' , '' , '' ; privatestaticchar [] skip_spaces = newchar [] {} '' ; privatestaticstring [] consequtive_spaces_pattern = spaces_list . Select () x => $ "" . ToArray () ; privatereadonlyRegexspaces_pattern = newRegex () $ "" | "" , RegexOptions . Compiled ; privatestaticList < UnicodeCategory > nonRenderingCategories = newList < UnicodeCategory > {} UnicodeCategory . Control , UnicodeCategory . OtherNotAssigned , UnicodeCategory . Surrogate , UnicodeCategory . Format ; privatestaticRegexstartSpaces = newRegex () @ "" , RegexOptions . Compiled | RegexOptions . Multiline ; privatestaticRegexendSpaces = newRegex () @ "" , RegexOptions . Compiled | RegexOptions . Multiline ; privatestaticRegexspacesInRow = newRegex () @ "" , RegexOptions . Compiled | RegexOptions . Multiline ; privateConcurrentBag < NGrammContainer > symbol_ngrams = newConcurrentBag < NGrammContainer > () ; privateConcurrentBag < NGrammContainer > words_ngrams = newConcurrentBag < NGrammContainer > () ; privateConcurrentBag < NGrammContainer > code_words_ngrams = newConcurrentBag < NGrammContainer > () ; privateConcurrentBag < NGrammContainer > literal_ngrams = newConcurrentBag < NGrammContainer > () ; privatereadonlystring_filename ; publicreadonlyProgressReporterprogressReporter ; publicNgrammProcessor () stringfilename , ProgressReporterreporter {} _filename = filename ; progressReporter = reporter ; CountDesiredVariables = 0 ; privatestaticboolIsEndSign () charch => endsigns . Contains () ch ; publicasyncTaskPreprocess () SimpleLogger_my_logger {} awaitTask . Run () () => {} Regexreg_exp = newRegex () @ "" ; _my_logger . Print () "" ; progressReporter . StartNewOperation () "" ; progressReporter . MoveProgress () 5 ; rawTextorg = reg_exp . Replace () File . ReadAllText () _filename , "" . Trim () . Replace () "" , "" ; fileEncoding = Utils . GetEncoding () _filename ; progressReporter . MoveProgress () 5 ; var_raw = newStringBuilder () ; var_uns = newStringBuilder () ; var_ends = newStringBuilder () ; varprogressMult = rawTextorg . Length / 90 ; varcurrentPr = 1 ; progressReporter . MoveProgress () ; for () inti = 0 ; i < rawTextorg . Length ; i ++ {} if () i >= progressMult * currentPr {} currentPr ++ ; progressReporter . MoveProgress () ; charch = rawTextorg [] i ; booladded = false ; if () char . IsLetter () ch || char . IsDigit () ch {} _raw . Append () ch ; _uns . Append () ch ; _ends . Append () ch ; ignore_spaces = ignore_ends = ignore_nlines = false ; elseif () ! ignore_spaces && () spaces_list . Contains () ch || ch == '' {} _raw . Append () ch ; _uns . Append () ch ; _ends . Append () ch ; ignore_spaces = true ; ignore_ends = false ; elseif () () ch == '' && ! ignore_nlines {} _raw . Append () ch ; _uns . Append () ch ; _ends . Append () ch ; ignore_spaces = true ; ignore_nlines = true ; ignore_ends = false ; elseif () ss . Contains () ch || ch == '' {} _raw . Append () ch ; elseif () ! ignore_ends && IsEndSign () ch {} _raw . Append () ch ; _ends . Append () ch ; else {} _raw . Append () ch ; rawTextorg = _raw . ToString () ; endsignedTextorg = _ends . ToString () ; unsignedTextorg = _uns . ToString () ; _raw . Clear () ; _ends . Clear () ; _uns . Clear () ; progressReporter . Finish () ;; publicList < NGrammContainer > ProcessLiteralNGrammsInWindow () intn , intwindowSize , intwindowStep , intstartPos , intendPos {} varres = newList < NGrammContainer > () ; intpos = startPos ; while () endPos >= pos + windowSize {} varcts = newNGrammContainer () Enumerable . Range () 1 , n . Select () nn => ProcessLiteralNgrmmToContainer () unsignedTextorg . Substring () pos , windowSize , nn , true . ToList () , n ; res . Add () cts ; pos += windowStep ; returnres ; publicTaskProcessLiteralNGramms () intn => Task . Run () () => {} progressReporter . StartNewOperation () $ "" ; vartext = RemoveConsequtiveSpaces () unsignedTextorg ; CountDesiredVariables = text . Length ; varprogressMult = text . Length * n / 95 ; ClearAllNGrammContainers () ; Parallel . For () 1 , n + 1 , PerformanceSettings . ParallelOpt , nn => {} varct = ProcessLiteralNgrmmToContainer () text , nn , false , progressMult ; literal_ngrams . Add () ct ;; literal_ngrams = newConcurrentBag < NGrammContainer > () literal_ngrams . OrderByDescending () w => w . n ; progressReporter . Finish () ;; privateNGrammContainerProcessLiteralNgrmmToContainer () stringtext , intn , boolcountDigits , intprogressMul = 0 {} varcontainer = newNGrammContainer () n ; boolbreaked ; charch ; intct = 1 ; text = spacesInRow . Replace () text , "" ; for () inti = 0 ; i < text . Length ; i ++ {} if () progressMul != 0 && i > progressMul * ct {} progressReporter . MoveProgress () ; ct ++ ; if () i + n - 1 < text . Length {} breaked = false ; stringngram = string . Empty ; for () intk = 0 ; k < n ; k ++ {} ch = text [] i + k ; varisSpace = spaces_pattern . Match () ch . ToString () . Success ; varnotPrintableSymbol = NonRenderingCategories () ch ; if () char . IsControl () ch {} breaked = true ; break ; if () process_spaces {} if () ! IsEndSign () ch && notPrintableSymbol {} if () isSpacengram += '' ; elsengram += ch ; else {} breaked = true ; break ; else {} if () ! IsEndSign () ch && ! spaces_list . Contains () ch && ! notPrintableSymbol {} ngram += ch ; else {} breaked = true ; break ; if () ! breaked {} container . Add () ignore_case ? ngram . ToLower () : ngram ; container . Process () ; returncontainer ; publicintGetLiteralCount () boolcountSpaces {} vartext = spacesInRow . Replace () unsignedTextorg , "" ; returntext . Count () c => char . IsLetter () c || () countSpaces && spaces_list . Contains () c ; publicList < NGrammContainer > ProcessSymbolNGrammsInWindow () intn , intwindowSize , intwindowStep , intstartPos , intendPos {} varres = newList < NGrammContainer > () ; intpos = startPos ; while () endPos >= pos + windowSize {} varcts = newNGrammContainer () Enumerable . Range () 1 , n . Select () nn => ProcessSymbolNgrmmToContainer () rawTextorg . Substring () pos , windowSize , nn . ToList () , n ; res . Add () cts ; pos += windowStep ; returnres ; publicTaskProcessSymbolNGramms () intn => Task . Run () () => {} progressReporter . StartNewOperation () $ "" ; vartext = rawTextorg ; if () ! consequtive_spaces {} text = RemoveConsequtiveSpaces () text ; if () ! show_NBS {} text = spacesInRow . Replace () text , "" ; CountDesiredVariables = text . Length ; ClearAllNGrammContainers () ; intprogressMul = text . Length / 95 ; Parallel . For () 1 , n + 1 , PerformanceSettings . ParallelOpt , nn => {} varct = ProcessSymbolNgrmmToContainer () text , nn , progressMul ; symbol_ngrams . Add () ct ;; symbol_ngrams = newConcurrentBag < NGrammContainer > () symbol_ngrams . OrderByDescending () w => w . n ; progressReporter . Finish () ;; privateNGrammContainerProcessSymbolNgrmmToContainer () stringtext , intn , intreportMul = 0 {} varcontainer = newNGrammContainer () n ; boolbreaked ; charch ; intct = 1 ; for () inti = 0 ; i < text . Length ; i ++ {} if () reportMul != 0 && i > reportMul * ct {} progressReporter . MoveProgress () ; ct ++ ; if () i + n - 1 < text . Length {} breaked = false ; StringBuilderngramBuilder = newStringBuilder () ; for () intk = 0 ; k < n ; k ++ {} ch = text [] i + k ; varisSpace = spaces_pattern . Match () ch . ToString () . Success ; varnotPrintableSymbol = NonRenderingCategories () ch ; if () process_spaces && ! notPrintableSymbol {} if () ! show_NBS && isSpace {} ngramBuilder . Append () '' ; elsengramBuilder . Append () ch ; else {} if () show_NBS && () isSpace || notPrintableSymbol {} ngramBuilder . Append () ch ; elseif () ! isSpace && ! notPrintableSymbol {} ngramBuilder . Append () ch ; else {} breaked = true ; break ; if () ! breaked {} varngram = ngramBuilder . ToString () ; ngramBuilder . Clear () ; container . Add () ignore_case ? ngram . ToLower () : ngram ; container . Process () ; returncontainer ; publicintGetSymbolsCount () boolcountSpaces {} vartext = rawTextorg ; if () ! consequtive_spaces {} text = RemoveConsequtiveSpaces () text ; if () ! show_NBS {} text = spacesInRow . Replace () text , "" ; returncountSpaces ? text . Length : text . Count () c => ! spaces_list . Contains () c ; publicList < NGrammContainer > ProcessWordNGrammsInWindow () string [] words , intn , intwindowSize , intwindowStep , intstartPos , intendPos {} varres = newList < NGrammContainer > () ; intpos = startPos ; while () endPos >= pos + windowSize {} varwrds = words . Skip () pos . Take () windowSize . ToArray () ; varcts = newNGrammContainer () Enumerable . Range () 1 , n . Select () nn => ProcessWordNgrmmToContainer () wrds , nn , false , ignore_case . ToList () , n ; res . Add () cts ; pos += windowStep ; returnres ; publicTaskProcessWordNGramms () intn {} returnTask . Run () () => {} progressReporter . StartNewOperation () $ "" ; progressReporter . MoveProgress () ; varwords = Words () ignore_punctuation ? unsignedTextorg : endsignedTextorg ; CountDesiredVariables = words . Length ; ClearAllNGrammContainers () ; intprogressMult = words . Length / 95 ; Parallel . For () 1 , n + 1 , PerformanceSettings . ParallelOpt , nn => {} varct = ProcessWordNgrmmToContainer () words , nn , ignore_punctuation , ignore_case , progressMult ; words_ngrams . Add () ct ;; words_ngrams = newConcurrentBag < NGrammContainer > () words_ngrams . OrderByDescending () w => w . n ; progressReporter . Finish () ;; publicintGetWordsCount () => Words () ignore_punctuation ? unsignedTextorg : endsignedTextorg . Length ; publicintGetCodeWordsCount () => TokenizeCode () File . ReadAllText () _filename , fileEncoding . ToArray () . Length ; privateNGrammContainerProcessWordNgrmmToContainer () string [] words , intn , boolskipss , boolignoreCase , intprogressMul = 0 , boolisCode = false {} varcontainer = newNGrammContainer () n ; boolbreaked ; intct = 1 ; for () inti = 0 ; i < words . Length ; i ++ {} if () progressMul != 0 && i > progressMul * ct {} progressReporter . MoveProgress () ; ct ++ ; if () i + n - 1 < words . Length {} breaked = false ; StringBuilderngramBuilder = newStringBuilder () ; for () intk = 0 ; k < n ; k ++ {} varword = words [] i + k ; if () string . IsNullOrWhiteSpace () word || word . All () x => NonRenderingCategories () x {} breaked = true ; break ; if () skipss {} if () word . Length > 1 && IsEndSign () word [] word . Length - 1word = word . Remove () word . Length - 1 ; if () ngramBuilder . Length == 0ngramBuilder . Append () word ; elsengramBuilder . Append () $ "" ; else {} if () ngramBuilder . Length == 0 {} ngramBuilder . Append () word ; elseif () ! IsEndSign () ngramBuilder [] ngramBuilder . Length - 1ngramBuilder . Append () $ "" ; else {} breaked = true ; break ; if () ! breaked {} varngram = ngramBuilder . ToString () ; if () ! isCode {} ngram = RemoveEndSigns () ngram ; ngramBuilder . Clear () ; container . Add () ignoreCase ? ngram . ToLower () : ngram ; container . Process () ; returncontainer ; publicTaskProcessCodeWordNGramms () intn , SimpleLoggermyLogger {} returnTask . Run () () => {} progressReporter . StartNewOperation () $ "" ; progressReporter . MoveProgress () ; stringcodeSample = File . ReadAllText () _filename , fileEncoding ; vartokens = TokenizeCode () codeSample ; varwords = TokenizeCode () codeSample . ToArray () ; myLogger . Print () "" + string . Join () "" , tokens ; myLogger . Print () $ "" ; foreach () varwinwords {} myLogger . Print () $ "" ; CountDesiredVariables = words . Length ; ClearAllNGrammContainers () ; intprogressMult = words . Length / 95 ; Parallel . For () 1 , n + 1 , PerformanceSettings . ParallelOpt , nn => {} varct = ProcessWordNgrmmToContainer () words , nn , false , false , progressMult , true ; code_words_ngrams . Add () ct ; myLogger . Print () $ "" ;; code_words_ngrams = newConcurrentBag < NGrammContainer > () code_words_ngrams . OrderByDescending () w => w . n ; progressReporter . Finish () ;; publicstaticstringRemoveCommentsAndStrings () stringcode {} varresult = newStringBuilder () ; inti = 0 ; intn = code . Length ; char ? inString = null ; boolescape = false ; while () i < n {} charch = code [] i ; if () inString != null {} if () escape {} escape = false ; result . Append () "" ; elseif () ch == '' {} escape = true ; result . Append () "" ; elseif () ch == inString {} result . Append () inString ; inString = null ; else {} result . Append () "" ; i ++ ; continue ; if () ch == '' || ch == '' {} inString = ch ; result . Append () ch ; i ++ ; continue ; if () ch == '' && i + 1 < n && code [] i + 1 == '' {} while () i < n && code [] i != '' i ++ ; result . Append () '' ; continue ; if () ch == '' && i + 1 < n && code [] i + 1 == '' {} i += 2 ; while () i + 1 < n && ! () code [] i == '' && code [] i + 1 == '' i ++ ; i += 2 ; result . Append () '' ; continue ; if () ch == '' {} while () i < n && code [] i != '' i ++ ; result . Append () '' ; continue ; if () ch == '' || ch == '' {} result . Append () '' ; i ++ ; continue ; result . Append () ch ; i ++ ; returnresult . ToString () ; publicstaticList < string > AddClosingBracket () List < string > code {} for () inti = 0 ; i < code . Count ; i ++ {} switch () code [] i {} case "" : code [] i = code [] i + "" ; break ; case "" : code [] i = code [] i + "" ; break ; case "" : code [] i = code [] i + "" ; break ; returncode ; publicstaticList < string > TokenizeCode () stringcode {} code = code . Replace () "" , "" ; code = RemoveCommentsAndStrings () code ; varresult = newList < string > () ; inti = 0 ; intn = code . Length ; varcurrent = newStringBuilder () ; stringstate = null ; varspecialExceptions = newHashSet < char > {} '' , '' , '' , '' , '' , '' , '' , '' , '' , '' , '' ; while () i < n {} charch = code [] i ; if () char . IsWhiteSpace () ch || ch == '' || ch == '' {} if () current . Length == 0 {} result . Add () current . ToString () ; current = newStringBuilder () ; state = null ; i ++ ; continue ; if () "" . Contains () ch {} i ++ ; continue ; if () "" . Contains () ch {} if () current . Length > 0 {} result . Add () current . ToString () ; current . Clear () ; state = null ; result . Add () ch . ToString () ; i ++ ; continue ; if () Utils . IsVariableChar () ch {} if () state == "" {} current . Append () ch ; else {} if () current . Length > 0result . Add () current . ToString () ; current . Clear () ; current . Append () ch ; state = "" ; i ++ ; continue ; if () Utils . IsDigit () ch {} if () state == "" {} current . Append () ch ; elseif () state == "" {} current . Append () ch ; else {} if () current . Length > 0result . Add () current . ToString () ; current . Clear () ; current . Append () ch ; state = "" ; i ++ ; continue ; if () ch == '' && state == "" && i + 1 < n && Utils . IsDigit () code [] i + 1 {} current . Append () '' ; i ++ ; continue ; if () ! specialExceptions . Contains () ch && ! Utils . IsVariableChar () ch && ! Utils . IsDigit () ch {} if () current . Length > 0 {} result . Add () current . ToString () ; current . Clear () ; state = null ; current . Append () ch ; i ++ ; while () i < n {} charnext = code [] i ; if () char . IsWhiteSpace () next || specialExceptions . Contains () next || Utils . IsVariableChar () next || Utils . IsDigit () nextbreak ; current . Append () next ; i ++ ; result . Add () current . ToString () ; current . Clear () ; state = null ; continue ; if () ch == '' {} if () current . Length > 0 {} result . Add () current . ToString () ; current . Clear () ; current . Append () ch ; i ++ ; while () i < n && code [] i != '' {} current . Append () code [] i ; i ++ ; current . Append () '' ; result . Add () current . ToString () ; current . Clear () ; i ++ ; continue ; if () ch == '' {} if () current . Length > 0 {} result . Add () current . ToString () ; current . Clear () ; current . Append () ch ; i ++ ; while () i < n && code [] i != '' {} current . Append () code [] i ; i ++ ; current . Append () '' ; result . Add () current . ToString () ; current . Clear () ; i ++ ; continue ; if () state == "" {} current . Append () ch ; else {} if () current . Length > 0result . Add () current . ToString () ; current . Clear () ; current . Append () ch ; state = "" ; i ++ ; if () current . Length > 0result . Add () current . ToString () ; for () intj = result . Count - 1 ; j >= 0 ; j -- {} result [] j = result [] j . Replace () "" , "" ; if () string . IsNullOrWhiteSpace () result [] jresult . RemoveAt () j ; returnAddClosingBracket () result ; privatestringRemoveEndSigns () stringword {} returnnewstring () word . Where () x => ! IsEndSign () x && () char . IsLetterOrDigit () x || char . IsWhiteSpace () x . ToArray () ; publicIReadOnlyCollection < NGrammContainer > GetLiteralNgrams () => literal_ngrams ; publicIReadOnlyCollection < NGrammContainer > GetSymbolNgrams () => symbol_ngrams ; publicIReadOnlyCollection < NGrammContainer > GetWordsNgrams () => words_ngrams ; publicIReadOnlyCollection < NGrammContainer > GetCodeWordsNgrams () => code_words_ngrams ; publicstaticstring [] Words () stringinputText {} vartext = startSpaces . Replace () inputText , "" ; text = endSpaces . Replace () text , "" ; vartextContainSpaces = text . Any () x => spaces_list . Except () skip_spaces . Contains () x ; varsplitList = newList < char > () spaces_list ; splitList . Add () '' ; if () textContainSpaces {} returntext . Split () splitList . ToArray () , StringSplitOptions . RemoveEmptyEntries ; returnTrySplitWords () text ; publicstaticstring [] TrySplitWords () stringinputText {} varanalysis = AnalyzeText () inputText ; if () analysis . Hiragana > 0 || analysis . Katakana > 0returnTokenizeJapanese () inputText ; elseif () analysis . Kanji > 0returnTokenizeChinese () inputText ; returninputText . Split () spaces_list . ToArray () , StringSplitOptions . RemoveEmptyEntries ; privatestatic () intHiragana , intKatakana , intKanjiAnalyzeText () stringinput {} inthiragana = 0 , katakana = 0 , kanji = 0 ; foreach () charcininput {} if () c >= '' && c <= '' hiragana ++ ; elseif () () c >= '' && c <= '' || () c >= '' && c <= '' || () c >= '' && c <= '' katakana ++ ; elseif () () c >= '' && c <= '' || () c >= '' && c <= '' kanji ++ ; return () hiragana , katakana , kanji ; privatestaticstring [] TokenizeJapanese () stringtext {} varparameter = newMeCabParam {} DicDir = Path . Combine () Path . GetTempPath () , "" ,; vartagger = MeCabTagger . Create () parameter ; varparsed = tagger . Parse () text ; returnparsed . Split () '' . Select () x => x . Split () '' [] 0 . ToArray () ; privatestaticstring [] TokenizeChinese () stringtext {} varsegmenter = newJiebaSegmenter () ; returnsegmenter . Cut () text , true . ToArray () ; privatevoidClearAllNGrammContainers () {} symbol_ngrams = newConcurrentBag < NGrammContainer > () ; literal_ngrams = newConcurrentBag < NGrammContainer > () ; words_ngrams = newConcurrentBag < NGrammContainer > () ; privatestringRemoveConsequtiveSpaces () stringinput {} varresult = input ; foreach () stringiteminconsequtive_spaces_pattern {} varregex = newRegex () item , RegexOptions . Multiline ; result = regex . Replace () result , match => {} returnmatch . Value [] 0 . ToString () ;; returnresult ; privateboolNonRenderingCategories () charc {} returnnonRenderingCategories . Contains () char . GetUnicodeCategory () c ;